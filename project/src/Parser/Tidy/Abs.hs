-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Parser.Tidy.Abs where

import Prelude (Char, Double, Integer, String)
import qualified Prelude as C (Eq, Ord, Show, Read, show, (++))
import qualified Data.String

newtype UpperCaseIdent = UpperCaseIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype LowerCaseIdent = LowerCaseIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

data Program = ProgramEntrypoint [ClassDecl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ClassIdent = ClassIdentifier UpperCaseIdent
  deriving (C.Eq, C.Ord, C.Read)

data ClassDecl
    = ClassDeclaration AbstractModifier ClassTypeModifier ClassType Inheritance ClassBody
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Inheritance = SuperclassAbsent | SuperclassPresent ClassType
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ClassBody
    = ClassBodyEmpty
    | ClassBodyFilled ValuesSection VariablesSection FunctionsSection ActionsSection
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ClassTypeModifier = MMutable | MImmutable | MSingleton
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data AbstractModifier = MConcrete | MAbstract
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ValuesSection = ValuesAbsent | ValuesPresent [ObjectDecl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data VariablesSection
    = VariablesAbsent | VariablesPresent [ObjectDecl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunctionsSection
    = FunctionsAbsent | FunctionsPresent [FunctionDecl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ActionsSection = ActionsAbsent | ActionsPresent [ActionDecl]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ObjectIdent = ObjectIdentifier LowerCaseIdent
  deriving (C.Eq, C.Ord, C.Read)

data ObjectType
    = ObjectTypeClass ClassType
    | ObjectTypeFunction MethodType
    | ObjectTypeAction MethodType
  deriving (C.Eq, C.Ord, C.Read)

data ClassType = GeneralClassType ClassIdent GenericParameter
  deriving (C.Eq, C.Ord, C.Read)

data GenericParameter
    = GenericParameterAbsent | GenericParameterPresent [ClassType]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ObjectDecl
    = ObjectDeclaration VisibilityModifier ObjectDeclProper
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data VisibilityModifier = MPublic | MPrivate
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ObjectDeclProper
    = ObjectDeclarationProper ObjectIdent ObjectType Initialization
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Initialization = Uninitialized | Initialized Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data MethodIdent = MethodIdentifier LowerCaseIdent
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data MethodType = MethodTypeSignature ParamList ObjectType
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ParamList = ParameterList [ObjectDeclProper]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunctionDecl
    = FunctionDeclaration OverrideModifier VisibilityModifier MethodIdent MethodType FunctionBody
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data OverrideModifier = MNonOverriding | MOverride
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunctionBody
    = FunctionBodyOneLine Expr | FunctionBodyMultiLine Expr WithValues
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data WithValues
    = WithValuesAbsent | WithValuesPresent ValuesSection
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ActionDecl
    = ActionDeclaration OverrideModifier VisibilityModifier MethodIdent MethodType ActionBody
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ActionBody
    = ActionBodyOneLine Expr | ActionBodyMultiLine [Expr]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Expr
    = ELiteral Literal
    | ELocalValue ObjectIdent
    | EGetExpression GetExpr
    | EDoExpression DoExpr
    | EConstructorCall CtorCall
    | ELambdaFunction LambdaFunction
    | ELambdaAction LambdaAction
    | EImperativeControlFlow ImperativeControlFlow
    | EFunctionalControlFlow FunctionalControlFlow
    | ELocalDeclaration LocalDecl
    | EUnaryNot Expr
    | EUnaryMinus Expr
    | EMultiply Expr Expr
    | EDivide Expr Expr
    | EModulo Expr Expr
    | EAdd Expr Expr
    | ESubtract Expr Expr
    | EConcatenate Expr Expr
    | ERelationalOperator Expr RelationalOperator Expr
    | EBooleanOperator Expr BooleanOperator Expr
    | EBuiltin MethodIdent
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Literal
    = LInt Integer
    | LBool Boolean
    | LChar Char
    | LString String
    | LVoid Void
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Boolean = BTrue | BFalse
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Void = VPass
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data LocalDecl
    = LocalValueDeclaration ObjectDecl
    | LocalVariableDeclaration ObjectDecl
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data LambdaFunction
    = LambdaFunctionOneLine ParamList Expr
    | LambdaFunctionMultiLine ParamList Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data LambdaAction
    = LambdaActionOneLine ParamList Expr
    | LambdaActionMultiLine ParamList [Expr]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ArgList = ArgumentListAbsent | ArgumentListPresent [MethodArg]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data MethodArg = MethodArgument Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunctionCall = CallFunction MethodIdent ArgList
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ActionCall = CallAction MethodIdent ArgList
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data CtorCall = CallConstructor ClassType ArgList
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data GetExpr
    = GetExpressionInstance ObjectIdent FunctionCall
    | GetExpressionStatic ClassType FunctionCall
    | GetExpressionChain GetExpr FunctionCall
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data DoExpr
    = DoExpressionInstance ObjectIdent ActionCall
    | DoExpressionStatic ClassType ActionCall
    | DoExpressionChain GetExpr ActionCall
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ImperativeControlFlow
    = IWhile Expr [Expr]
    | IForeach ObjectDecl Expr [Expr]
    | IIf Expr [Expr] OptionalElseBranch
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data OptionalElseBranch
    = IElsePresent [Expr]
    | IElseIf Expr [Expr] OptionalElseBranch
    | IElseAbsent
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data FunctionalControlFlow
    = FIfThenElse Expr ThenBranch ElseBranch
    | FMatchCase Expr [MatchCase]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ThenBranch = FThenOneLine Expr | FThenMultiLine Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data ElseBranch
    = FElseOneLine Expr
    | FElseMultiLine Expr
    | FElseIf Expr ThenBranch ElseBranch
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data MatchCase = FCase Pattern Expr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Pattern = FTypePattern ClassType
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data RelationalOperator
    = RLess
    | RLessEqual
    | RGreater
    | RGreaterEqual
    | REqual
    | RNotEqual
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data BooleanOperator = BAnd | BOr
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Show ObjectIdent where
    show (ObjectIdentifier (LowerCaseIdent identifier)) = identifier

instance C.Show ClassIdent where
    show (ClassIdentifier (UpperCaseIdent identifier)) = identifier

instance C.Show ClassType where
    show (GeneralClassType classIdent GenericParameterAbsent) = C.show classIdent
    show (GeneralClassType classIdent (GenericParameterPresent genericParams)) = C.show classIdent C.++ C.show genericParams

instance C.Show ObjectType where
    show (ObjectTypeClass classType) = C.show classType
    show (ObjectTypeFunction methodType) = C.show methodType
    show (ObjectTypeAction methodType) = C.show methodType

-- TODO add instance for lambda types when properly supported in the interpreter
