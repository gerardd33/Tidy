-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.Tidy.Par
  ( happyError
  , myLexer
  , pProgram
  ) where
import qualified Parser.Tidy.Abs
import Parser.Tidy.Lex
}

%name pProgram Program
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '#' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '(' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '+' { PT _ (TS _ 7) }
  '++' { PT _ (TS _ 8) }
  ',' { PT _ (TS _ 9) }
  '-' { PT _ (TS _ 10) }
  '->' { PT _ (TS _ 11) }
  '.' { PT _ (TS _ 12) }
  '/' { PT _ (TS _ 13) }
  ':' { PT _ (TS _ 14) }
  ';' { PT _ (TS _ 15) }
  '<' { PT _ (TS _ 16) }
  '<=' { PT _ (TS _ 17) }
  '=' { PT _ (TS _ 18) }
  '==' { PT _ (TS _ 19) }
  '>' { PT _ (TS _ 20) }
  '>=' { PT _ (TS _ 21) }
  'False' { PT _ (TS _ 22) }
  'Pass' { PT _ (TS _ 23) }
  'True' { PT _ (TS _ 24) }
  '[' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  'abstract' { PT _ (TS _ 27) }
  'actions:' { PT _ (TS _ 28) }
  'and' { PT _ (TS _ 29) }
  'case' { PT _ (TS _ 30) }
  'class' { PT _ (TS _ 31) }
  'do' { PT _ (TS _ 32) }
  'elif' { PT _ (TS _ 33) }
  'else' { PT _ (TS _ 34) }
  'extends' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'functions:' { PT _ (TS _ 37) }
  'get' { PT _ (TS _ 38) }
  'if' { PT _ (TS _ 39) }
  'immutable' { PT _ (TS _ 40) }
  'in' { PT _ (TS _ 41) }
  'match' { PT _ (TS _ 42) }
  'mutable' { PT _ (TS _ 43) }
  'not' { PT _ (TS _ 44) }
  'or' { PT _ (TS _ 45) }
  'override' { PT _ (TS _ 46) }
  'private' { PT _ (TS _ 47) }
  'singleton' { PT _ (TS _ 48) }
  'then' { PT _ (TS _ 49) }
  'val' { PT _ (TS _ 50) }
  'values:' { PT _ (TS _ 51) }
  'var' { PT _ (TS _ 52) }
  'variables:' { PT _ (TS _ 53) }
  'while' { PT _ (TS _ 54) }
  'with' { PT _ (TS _ 55) }
  '{' { PT _ (TS _ 56) }
  '}' { PT _ (TS _ 57) }
  L_charac { PT _ (TC $$) }
  L_integ  { PT _ (TI $$) }
  L_quoted { PT _ (TL $$) }
  L_UpperCaseIdent { PT _ (T_UpperCaseIdent $$) }
  L_LowerCaseIdent { PT _ (T_LowerCaseIdent $$) }

%%

Char    :: { Char }
Char     : L_charac { (read ($1)) :: Char }

Integer :: { Integer }
Integer  : L_integ  { (read ($1)) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

UpperCaseIdent :: { Parser.Tidy.Abs.UpperCaseIdent}
UpperCaseIdent  : L_UpperCaseIdent { Parser.Tidy.Abs.UpperCaseIdent $1 }

LowerCaseIdent :: { Parser.Tidy.Abs.LowerCaseIdent}
LowerCaseIdent  : L_LowerCaseIdent { Parser.Tidy.Abs.LowerCaseIdent $1 }

Program :: { Parser.Tidy.Abs.Program }
Program : ListClassDecl { Parser.Tidy.Abs.ProgramEntrypoint $1 }

ListClassIdent :: { [Parser.Tidy.Abs.ClassIdent] }
ListClassIdent : {- empty -} { [] }
               | ClassIdent { (:[]) $1 }
               | ClassIdent ',' ListClassIdent { (:) $1 $3 }

ClassIdent :: { Parser.Tidy.Abs.ClassIdent }
ClassIdent : UpperCaseIdent { Parser.Tidy.Abs.ClassIdentifier $1 }

ListClassDecl :: { [Parser.Tidy.Abs.ClassDecl] }
ListClassDecl : ClassDecl { (:[]) $1 }
              | ClassDecl ListClassDecl { (:) $1 $2 }

ClassDecl :: { Parser.Tidy.Abs.ClassDecl }
ClassDecl : AbstractModifier ClassTypeModifier 'class' ClassIdent Inheritance ClassBody { Parser.Tidy.Abs.ClassDeclaration $1 $2 $4 $5 $6 }

Inheritance :: { Parser.Tidy.Abs.Inheritance }
Inheritance : {- empty -} { Parser.Tidy.Abs.SuperclassAbsent }
            | 'extends' ClassIdent { Parser.Tidy.Abs.SuperclassPresent $2 }

ClassBody :: { Parser.Tidy.Abs.ClassBody }
ClassBody : {- empty -} { Parser.Tidy.Abs.ClassBodyEmpty }
          | '{' ValuesSection VariablesSection FunctionsSection ActionsSection '}' { Parser.Tidy.Abs.ClassBodyFilled $2 $3 $4 $5 }

ClassTypeModifier :: { Parser.Tidy.Abs.ClassTypeModifier }
ClassTypeModifier : 'mutable' { Parser.Tidy.Abs.MMutable }
                  | 'immutable' { Parser.Tidy.Abs.MImmutable }
                  | 'singleton' { Parser.Tidy.Abs.MSingleton }

AbstractModifier :: { Parser.Tidy.Abs.AbstractModifier }
AbstractModifier : {- empty -} { Parser.Tidy.Abs.MConcrete }
                 | 'abstract' { Parser.Tidy.Abs.MAbstract }

ValuesSection :: { Parser.Tidy.Abs.ValuesSection }
ValuesSection : {- empty -} { Parser.Tidy.Abs.ValuesAbsent }
              | 'values:' '{' ListObjectDecl '}' { Parser.Tidy.Abs.ValuesPresent $3 }

VariablesSection :: { Parser.Tidy.Abs.VariablesSection }
VariablesSection : {- empty -} { Parser.Tidy.Abs.VariablesAbsent }
                 | 'variables:' '{' ListObjectDecl '}' { Parser.Tidy.Abs.VariablesPresent $3 }

FunctionsSection :: { Parser.Tidy.Abs.FunctionsSection }
FunctionsSection : {- empty -} { Parser.Tidy.Abs.FunctionsAbsent }
                 | 'functions:' '{' ListFunctionDecl '}' { Parser.Tidy.Abs.FunctionsPresent $3 }

ActionsSection :: { Parser.Tidy.Abs.ActionsSection }
ActionsSection : {- empty -} { Parser.Tidy.Abs.ActionsAbsent }
               | 'actions:' '{' ListActionDecl '}' { Parser.Tidy.Abs.ActionsPresent $3 }

ObjectIdent :: { Parser.Tidy.Abs.ObjectIdent }
ObjectIdent : LowerCaseIdent { Parser.Tidy.Abs.ObjectIdentifier $1 }

ObjectType :: { Parser.Tidy.Abs.ObjectType }
ObjectType : ClassIdent GenericParameter { Parser.Tidy.Abs.ObjectTypeClass $1 $2 }
           | 'get' MethodType { Parser.Tidy.Abs.ObjectTypeFunction $2 }
           | 'do' MethodType { Parser.Tidy.Abs.ObjectTypeAction $2 }

GenericParameter :: { Parser.Tidy.Abs.GenericParameter }
GenericParameter : {- empty -} { Parser.Tidy.Abs.GenericParameterAbsent }
                 | '[' ListClassIdent ']' { Parser.Tidy.Abs.GenericParameterPresent $2 }

ListObjectDecl :: { [Parser.Tidy.Abs.ObjectDecl] }
ListObjectDecl : {- empty -} { [] }
               | ObjectDecl ListObjectDecl { (:) $1 $2 }

ObjectDecl :: { Parser.Tidy.Abs.ObjectDecl }
ObjectDecl : VisibilityModifier ObjectDeclProper ';' { Parser.Tidy.Abs.ObjectDeclaration $1 $2 }

VisibilityModifier :: { Parser.Tidy.Abs.VisibilityModifier }
VisibilityModifier : {- empty -} { Parser.Tidy.Abs.MPublic }
                   | 'private' { Parser.Tidy.Abs.MPrivate }

ListObjectDeclProper :: { [Parser.Tidy.Abs.ObjectDeclProper] }
ListObjectDeclProper : {- empty -} { [] }
                     | ObjectDeclProper { (:[]) $1 }
                     | ObjectDeclProper ',' ListObjectDeclProper { (:) $1 $3 }

ObjectDeclProper :: { Parser.Tidy.Abs.ObjectDeclProper }
ObjectDeclProper : ObjectIdent ':' ObjectType Initialization { Parser.Tidy.Abs.ObjectDeclarationProper $1 $3 $4 }

Initialization :: { Parser.Tidy.Abs.Initialization }
Initialization : {- empty -} { Parser.Tidy.Abs.Uninitialized }
               | '=' Expr { Parser.Tidy.Abs.Initialized $2 }

MethodIdent :: { Parser.Tidy.Abs.MethodIdent }
MethodIdent : LowerCaseIdent { Parser.Tidy.Abs.MethodIdentifier $1 }

MethodType :: { Parser.Tidy.Abs.MethodType }
MethodType : ParamList '->' ObjectType { Parser.Tidy.Abs.MethodTypeSignature $1 $3 }

ParamList :: { Parser.Tidy.Abs.ParamList }
ParamList : '(' ListObjectDeclProper ')' { Parser.Tidy.Abs.ParameterList $2 }

ListFunctionDecl :: { [Parser.Tidy.Abs.FunctionDecl] }
ListFunctionDecl : {- empty -} { [] }
                 | FunctionDecl ListFunctionDecl { (:) $1 $2 }

FunctionDecl :: { Parser.Tidy.Abs.FunctionDecl }
FunctionDecl : OverrideModifier VisibilityModifier MethodIdent ':' MethodType '=' FunctionBody { Parser.Tidy.Abs.FunctionDeclaration $1 $2 $3 $5 $7 }

OverrideModifier :: { Parser.Tidy.Abs.OverrideModifier }
OverrideModifier : {- empty -} { Parser.Tidy.Abs.MNonOverriding }
                 | 'override' { Parser.Tidy.Abs.MOverride }

FunctionBody :: { Parser.Tidy.Abs.FunctionBody }
FunctionBody : Expr { Parser.Tidy.Abs.FunctionBodyOneLine $1 }
             | '{' Expr '}' WithValues { Parser.Tidy.Abs.FunctionBodyMultiLine $2 $4 }

WithValues :: { Parser.Tidy.Abs.WithValues }
WithValues : {- empty -} { Parser.Tidy.Abs.WithValuesAbsent }
           | 'with' ValuesSection { Parser.Tidy.Abs.WithValuesPresent $2 }

ListActionDecl :: { [Parser.Tidy.Abs.ActionDecl] }
ListActionDecl : {- empty -} { [] }
               | ActionDecl ListActionDecl { (:) $1 $2 }

ActionDecl :: { Parser.Tidy.Abs.ActionDecl }
ActionDecl : OverrideModifier VisibilityModifier MethodIdent ':' MethodType '=' ActionBody { Parser.Tidy.Abs.ActionDeclaration $1 $2 $3 $5 $7 }

ActionBody :: { Parser.Tidy.Abs.ActionBody }
ActionBody : Expr { Parser.Tidy.Abs.ActionBodyOneLine $1 }
           | '{' ListExpr '}' { Parser.Tidy.Abs.ActionBodyMultiLine $2 }

ListExpr :: { [Parser.Tidy.Abs.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

Expr :: { Parser.Tidy.Abs.Expr }
Expr : Expr1 { $1 }
     | Expr1 BooleanOperator Expr { Parser.Tidy.Abs.EBooleanOperator $1 $2 $3 }

Expr1 :: { Parser.Tidy.Abs.Expr }
Expr1 : Expr2 { $1 }
      | Expr1 RelationalOperator Expr2 { Parser.Tidy.Abs.ERelationalOperator $1 $2 $3 }

Expr2 :: { Parser.Tidy.Abs.Expr }
Expr2 : Expr3 { $1 }
      | Expr2 '+' Expr3 { Parser.Tidy.Abs.EAdd $1 $3 }
      | Expr2 '-' Expr3 { Parser.Tidy.Abs.ESubtract $1 $3 }
      | Expr2 '++' Expr3 { Parser.Tidy.Abs.EConcatenate $1 $3 }

Expr3 :: { Parser.Tidy.Abs.Expr }
Expr3 : Expr4 { $1 }
      | Expr3 '*' Expr4 { Parser.Tidy.Abs.EMultiply $1 $3 }
      | Expr3 '/' Expr4 { Parser.Tidy.Abs.EDivide $1 $3 }
      | Expr3 '%' Expr4 { Parser.Tidy.Abs.EModulo $1 $3 }

Expr4 :: { Parser.Tidy.Abs.Expr }
Expr4 : Expr5 { $1 }
      | 'not' Expr5 { Parser.Tidy.Abs.EUnaryNot $2 }
      | '-' Expr5 { Parser.Tidy.Abs.EUnaryMinus $2 }

Expr5 :: { Parser.Tidy.Abs.Expr }
Expr5 : Expr6 { $1 }
      | LocalDecl { Parser.Tidy.Abs.ELocalDeclaration $1 }

Expr6 :: { Parser.Tidy.Abs.Expr }
Expr6 : Expr7 { $1 }
      | ImperativeControlFlow { Parser.Tidy.Abs.EImperativeControlFlow $1 }
      | FunctionalControlFlow { Parser.Tidy.Abs.EFunctionalControlFlow $1 }

Expr7 :: { Parser.Tidy.Abs.Expr }
Expr7 : Expr8 { $1 }
      | LambdaFunction { Parser.Tidy.Abs.ELambdaFunction $1 }
      | LambdaAction { Parser.Tidy.Abs.ELambdaAction $1 }

Expr8 :: { Parser.Tidy.Abs.Expr }
Expr8 : Expr9 { $1 }
      | CtorCall { Parser.Tidy.Abs.EConstructorCall $1 }

Expr9 :: { Parser.Tidy.Abs.Expr }
Expr9 : Expr10 { $1 }
      | GetExpr { Parser.Tidy.Abs.EGetExpression $1 }
      | DoExpr { Parser.Tidy.Abs.EDoExpression $1 }

Expr10 :: { Parser.Tidy.Abs.Expr }
Expr10 : '(' Expr ')' { $2 }
       | Literal { Parser.Tidy.Abs.ELiteral $1 }
       | ObjectIdent { Parser.Tidy.Abs.ELocalValue $1 }

Literal :: { Parser.Tidy.Abs.Literal }
Literal : Integer { Parser.Tidy.Abs.LInt $1 }
        | Boolean { Parser.Tidy.Abs.LBool $1 }
        | Char { Parser.Tidy.Abs.LChar $1 }
        | String { Parser.Tidy.Abs.LString $1 }
        | Void { Parser.Tidy.Abs.LVoid $1 }

Boolean :: { Parser.Tidy.Abs.Boolean }
Boolean : 'True' { Parser.Tidy.Abs.BTrue }
        | 'False' { Parser.Tidy.Abs.BFalse }

Void :: { Parser.Tidy.Abs.Void }
Void : 'Pass' { Parser.Tidy.Abs.VPass }

LocalDecl :: { Parser.Tidy.Abs.LocalDecl }
LocalDecl : 'val' ObjectDecl { Parser.Tidy.Abs.LocalValueDeclaration $2 }
          | 'var' ObjectDecl { Parser.Tidy.Abs.LocalVariableDeclaration $2 }

LambdaFunction :: { Parser.Tidy.Abs.LambdaFunction }
LambdaFunction : 'get' ParamList '->' Expr ';' { Parser.Tidy.Abs.LambdaFunctionOneLine $2 $4 }
               | 'get' ParamList '->' '{' Expr '}' { Parser.Tidy.Abs.LambdaFunctionMultiLine $2 $5 }

LambdaAction :: { Parser.Tidy.Abs.LambdaAction }
LambdaAction : 'do' ParamList '->' Expr ';' { Parser.Tidy.Abs.LambdaActionOneLine $2 $4 }
             | 'do' ParamList '->' '{' ListExpr '}' { Parser.Tidy.Abs.LambdaActionMultiLine $2 $5 }

ArgList :: { Parser.Tidy.Abs.ArgList }
ArgList : {- empty -} { Parser.Tidy.Abs.ArgumentListAbsent }
        | '(' ListMethodArg ')' { Parser.Tidy.Abs.ArgumentListPresent $2 }

ListMethodArg :: { [Parser.Tidy.Abs.MethodArg] }
ListMethodArg : {- empty -} { [] }
              | MethodArg { (:[]) $1 }
              | MethodArg ',' ListMethodArg { (:) $1 $3 }

MethodArg :: { Parser.Tidy.Abs.MethodArg }
MethodArg : Expr { Parser.Tidy.Abs.MethodArgument $1 }

FunctionCall :: { Parser.Tidy.Abs.FunctionCall }
FunctionCall : '.' MethodIdent ArgList { Parser.Tidy.Abs.CallFunction $2 $3 }

ActionCall :: { Parser.Tidy.Abs.ActionCall }
ActionCall : '#' MethodIdent ArgList { Parser.Tidy.Abs.CallAction $2 $3 }

CtorCall :: { Parser.Tidy.Abs.CtorCall }
CtorCall : ClassIdent ArgList { Parser.Tidy.Abs.CallConstructor $1 $2 }

GetExpr :: { Parser.Tidy.Abs.GetExpr }
GetExpr : ObjectIdent FunctionCall { Parser.Tidy.Abs.GetExpressionInstance $1 $2 }
        | ClassIdent FunctionCall { Parser.Tidy.Abs.GetExpressionStatic $1 $2 }
        | GetExpr FunctionCall { Parser.Tidy.Abs.GetExpressionChain $1 $2 }

DoExpr :: { Parser.Tidy.Abs.DoExpr }
DoExpr : ObjectIdent ActionCall { Parser.Tidy.Abs.DoExpressionInstance $1 $2 }
       | ClassIdent ActionCall { Parser.Tidy.Abs.DoExpressionStatic $1 $2 }
       | GetExpr ActionCall { Parser.Tidy.Abs.DoExpressionChain $1 $2 }

ImperativeControlFlow :: { Parser.Tidy.Abs.ImperativeControlFlow }
ImperativeControlFlow : 'while' '(' Expr ')' '{' ListExpr '}' { Parser.Tidy.Abs.IWhile $3 $6 }
                      | 'for' '(' ObjectDecl 'in' Expr ')' '{' ListExpr '}' { Parser.Tidy.Abs.IForeach $3 $5 $8 }
                      | 'if' '(' Expr ')' '{' ListExpr '}' OptionalElseBranch { Parser.Tidy.Abs.IIf $3 $6 $8 }

OptionalElseBranch :: { Parser.Tidy.Abs.OptionalElseBranch }
OptionalElseBranch : 'else' '{' ListExpr '}' { Parser.Tidy.Abs.IElsePresent $3 }
                   | 'elif' '(' Expr ')' '{' ListExpr '}' OptionalElseBranch { Parser.Tidy.Abs.IElseIf $3 $6 $8 }
                   | {- empty -} { Parser.Tidy.Abs.IElseAbsent }

FunctionalControlFlow :: { Parser.Tidy.Abs.FunctionalControlFlow }
FunctionalControlFlow : 'if' '(' Expr ')' ThenBranch ElseBranch { Parser.Tidy.Abs.FIfThenElse $3 $5 $6 }
                      | 'match' Expr '{' ListMatchCase '}' { Parser.Tidy.Abs.FMatchCase $2 $4 }

ThenBranch :: { Parser.Tidy.Abs.ThenBranch }
ThenBranch : 'then' Expr ';' { Parser.Tidy.Abs.FThenOneLine $2 }
           | 'then' '{' Expr '}' { Parser.Tidy.Abs.FThenMultiLine $3 }

ElseBranch :: { Parser.Tidy.Abs.ElseBranch }
ElseBranch : 'else' Expr ';' { Parser.Tidy.Abs.FElseOneLine $2 }
           | 'else' '{' Expr '}' { Parser.Tidy.Abs.FElseMultiLine $3 }
           | 'elif' '(' Expr ')' ThenBranch ElseBranch { Parser.Tidy.Abs.FElseIf $3 $5 $6 }

ListMatchCase :: { [Parser.Tidy.Abs.MatchCase] }
ListMatchCase : {- empty -} { [] }
              | MatchCase ListMatchCase { (:) $1 $2 }

MatchCase :: { Parser.Tidy.Abs.MatchCase }
MatchCase : 'case' Pattern '->' Expr { Parser.Tidy.Abs.FCase $2 $4 }

Pattern :: { Parser.Tidy.Abs.Pattern }
Pattern : ClassIdent { Parser.Tidy.Abs.FTypePattern $1 }

RelationalOperator :: { Parser.Tidy.Abs.RelationalOperator }
RelationalOperator : '<' { Parser.Tidy.Abs.RLess }
                   | '<=' { Parser.Tidy.Abs.RLessEqual }
                   | '>' { Parser.Tidy.Abs.RGreater }
                   | '>=' { Parser.Tidy.Abs.RGreaterEqual }
                   | '==' { Parser.Tidy.Abs.REqual }
                   | '!=' { Parser.Tidy.Abs.RNotEqual }

BooleanOperator :: { Parser.Tidy.Abs.BooleanOperator }
BooleanOperator : 'and' { Parser.Tidy.Abs.BAnd }
                | 'or' { Parser.Tidy.Abs.BOr }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

