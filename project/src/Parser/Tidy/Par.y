-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parser.Tidy.Par
  ( happyError
  , myLexer
  , pProgram
  ) where
import qualified Parser.Tidy.Abs as Tidy.Abs
import Parser.Tidy.Lex
}

%name pProgram Program
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '#' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  '++' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '->' { PT _ (TS _ 10) }
  '.' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ':' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  'False' { PT _ (TS _ 21) }
  'Pass' { PT _ (TS _ 22) }
  'True' { PT _ (TS _ 23) }
  '[' { PT _ (TS _ 24) }
  ']' { PT _ (TS _ 25) }
  'abstract' { PT _ (TS _ 26) }
  'actions:' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'case' { PT _ (TS _ 29) }
  'class' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'elif' { PT _ (TS _ 32) }
  'else' { PT _ (TS _ 33) }
  'extends' { PT _ (TS _ 34) }
  'for' { PT _ (TS _ 35) }
  'functions:' { PT _ (TS _ 36) }
  'get' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'immutable' { PT _ (TS _ 39) }
  'in' { PT _ (TS _ 40) }
  'local' { PT _ (TS _ 41) }
  'match' { PT _ (TS _ 42) }
  'mutable' { PT _ (TS _ 43) }
  'not' { PT _ (TS _ 44) }
  'or' { PT _ (TS _ 45) }
  'override' { PT _ (TS _ 46) }
  'private' { PT _ (TS _ 47) }
  'singleton' { PT _ (TS _ 48) }
  'then' { PT _ (TS _ 49) }
  'value' { PT _ (TS _ 50) }
  'values:' { PT _ (TS _ 51) }
  'variables:' { PT _ (TS _ 52) }
  'while' { PT _ (TS _ 53) }
  'with' { PT _ (TS _ 54) }
  '{' { PT _ (TS _ 55) }
  '}' { PT _ (TS _ 56) }
  L_charac { PT _ (TC $$) }
  L_integ  { PT _ (TI $$) }
  L_quoted { PT _ (TL $$) }
  L_UpperCaseIdent { PT _ (T_UpperCaseIdent $$) }
  L_LowerCaseIdent { PT _ (T_LowerCaseIdent $$) }

%%

Char    :: { Char }
Char     : L_charac { (read ($1)) :: Char }

Integer :: { Integer }
Integer  : L_integ  { (read ($1)) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

UpperCaseIdent :: { Tidy.Abs.UpperCaseIdent}
UpperCaseIdent  : L_UpperCaseIdent { Tidy.Abs.UpperCaseIdent $1 }

LowerCaseIdent :: { Tidy.Abs.LowerCaseIdent}
LowerCaseIdent  : L_LowerCaseIdent { Tidy.Abs.LowerCaseIdent $1 }

Program :: { Tidy.Abs.Program }
Program : ListClassDecl { Tidy.Abs.ProgramEntrypoint $1 }

ListClassIdent :: { [Tidy.Abs.ClassIdent] }
ListClassIdent : {- empty -} { [] }
               | ClassIdent { (:[]) $1 }
               | ClassIdent ',' ListClassIdent { (:) $1 $3 }

ClassIdent :: { Tidy.Abs.ClassIdent }
ClassIdent : UpperCaseIdent { Tidy.Abs.CIdent $1 }

ListClassDecl :: { [Tidy.Abs.ClassDecl] }
ListClassDecl : ClassDecl { (:[]) $1 }
              | ClassDecl ListClassDecl { (:) $1 $2 }

ClassDecl :: { Tidy.Abs.ClassDecl }
ClassDecl : ClassType 'class' ClassIdent Inheritance ClassBody { Tidy.Abs.ClassDeclConcrete $1 $3 $4 $5 }
          | 'abstract' ClassType 'class' ClassIdent Inheritance ClassBody { Tidy.Abs.ClassDeclAbstract $2 $4 $5 $6 }

Inheritance :: { Tidy.Abs.Inheritance }
Inheritance : {- empty -} { Tidy.Abs.SuperclassAbsent }
            | 'extends' ClassIdent { Tidy.Abs.SuperclassPresent $2 }

ClassBody :: { Tidy.Abs.ClassBody }
ClassBody : {- empty -} { Tidy.Abs.ClassBodyEmpty }
          | '{' ValuesSection VariablesSection FunctionsSection ActionsSection '}' { Tidy.Abs.ClassBodyFilled $2 $3 $4 $5 }

ClassType :: { Tidy.Abs.ClassType }
ClassType : 'mutable' { Tidy.Abs.MMutable }
          | 'immutable' { Tidy.Abs.MImmutable }
          | 'singleton' { Tidy.Abs.MSingleton }

ValuesSection :: { Tidy.Abs.ValuesSection }
ValuesSection : {- empty -} { Tidy.Abs.ValuesAbsent }
              | 'values:' ValSBody { Tidy.Abs.ValuesPresent $2 }

VariablesSection :: { Tidy.Abs.VariablesSection }
VariablesSection : {- empty -} { Tidy.Abs.VariablesAbsent }
                 | 'variables:' VarSBody { Tidy.Abs.VariablesPresent $2 }

FunctionsSection :: { Tidy.Abs.FunctionsSection }
FunctionsSection : {- empty -} { Tidy.Abs.FunctionsAbsent }
                 | 'functions:' FSBody { Tidy.Abs.FunctionsPresent $2 }

ActionsSection :: { Tidy.Abs.ActionsSection }
ActionsSection : {- empty -} { Tidy.Abs.ActionsAbsent }
               | 'actions:' ASBody { Tidy.Abs.ActionsPresent $2 }

ValSBody :: { Tidy.Abs.ValSBody }
ValSBody : '{' ListValueDecl '}' { Tidy.Abs.ValuesSBody $2 }

ValueIdent :: { Tidy.Abs.ValueIdent }
ValueIdent : LowerCaseIdent { Tidy.Abs.VIdent $1 }

ValueType :: { Tidy.Abs.ValueType }
ValueType : ClassIdent { Tidy.Abs.ValueTypeClass $1 }
          | ClassIdent '[' ListClassIdent ']' { Tidy.Abs.ValueTypeGeneric $1 $3 }
          | 'get' MethodType { Tidy.Abs.ValueTypeFunction $2 }
          | 'do' MethodType { Tidy.Abs.ValueTypeAction $2 }

ListValueDecl :: { [Tidy.Abs.ValueDecl] }
ListValueDecl : {- empty -} { [] }
              | ValueDecl ListValueDecl { (:) $1 $2 }

ValueDecl :: { Tidy.Abs.ValueDecl }
ValueDecl : ValueDeclProper ';' { Tidy.Abs.PublicValueDecl $1 }
          | 'private' ValueDeclProper ';' { Tidy.Abs.PrivateValueDecl $2 }

ListValueDeclProper :: { [Tidy.Abs.ValueDeclProper] }
ListValueDeclProper : {- empty -} { [] }
                    | ValueDeclProper { (:[]) $1 }
                    | ValueDeclProper ',' ListValueDeclProper { (:) $1 $3 }

ValueDeclProper :: { Tidy.Abs.ValueDeclProper }
ValueDeclProper : ValueIdent ':' ValueType { Tidy.Abs.UninitialisedValue $1 $3 }
                | ValueIdent ':' ValueType '=' Expr { Tidy.Abs.InitialisedValue $1 $3 $5 }

VarSBody :: { Tidy.Abs.VarSBody }
VarSBody : '{' ListValueDecl '}' { Tidy.Abs.VariablesSBody $2 }

FSBody :: { Tidy.Abs.FSBody }
FSBody : {- empty -} { Tidy.Abs.FSBodyEmpty }
       | '{' ListFunctionDecl '}' { Tidy.Abs.FSBodyFilled $2 }

FunctionIdent :: { Tidy.Abs.FunctionIdent }
FunctionIdent : LowerCaseIdent { Tidy.Abs.FIdent $1 }

MethodType :: { Tidy.Abs.MethodType }
MethodType : ParameterList '->' ValueType { Tidy.Abs.FType $1 $3 }

ParameterList :: { Tidy.Abs.ParameterList }
ParameterList : '(' ListValueDeclProper ')' { Tidy.Abs.ParamList $2 }

ListFunctionDecl :: { [Tidy.Abs.FunctionDecl] }
ListFunctionDecl : {- empty -} { [] }
                 | FunctionDecl ListFunctionDecl { (:) $1 $2 }

FunctionDecl :: { Tidy.Abs.FunctionDecl }
FunctionDecl : 'override' FunctionIdent ':' MethodType '=' FunctionBody { Tidy.Abs.OverrideFunctionDecl $2 $4 $6 }
             | FunctionIdent ':' MethodType '=' FunctionBody { Tidy.Abs.PublicFunctionDecl $1 $3 $5 }
             | 'private' FunctionIdent ':' MethodType '=' FunctionBody { Tidy.Abs.PrivateFunctionDecl $2 $4 $6 }

FunctionBody :: { Tidy.Abs.FunctionBody }
FunctionBody : Expr { Tidy.Abs.FunctionBodyOneLine $1 }
             | '{' Expr '}' WithValues { Tidy.Abs.FunctionBodyMultiLine $2 $4 }

WithValues :: { Tidy.Abs.WithValues }
WithValues : {- empty -} { Tidy.Abs.WithValuesAbsent }
           | 'with' ValuesSection { Tidy.Abs.WithValuesPresent $2 }

ASBody :: { Tidy.Abs.ASBody }
ASBody : {- empty -} { Tidy.Abs.ASBodyEmpty }
       | '{' ListActionDecl '}' { Tidy.Abs.ASBodyFilled $2 }

ListActionDecl :: { [Tidy.Abs.ActionDecl] }
ListActionDecl : {- empty -} { [] }
               | ActionDecl ListActionDecl { (:) $1 $2 }

ActionDecl :: { Tidy.Abs.ActionDecl }
ActionDecl : 'override' FunctionIdent ':' MethodType '=' ActionBody { Tidy.Abs.OverrideActionDecl $2 $4 $6 }
           | FunctionIdent ':' MethodType '=' ActionBody { Tidy.Abs.PublicActionDecl $1 $3 $5 }
           | 'private' FunctionIdent ':' MethodType '=' ActionBody { Tidy.Abs.PrivateActionDecl $2 $4 $6 }

ActionBody :: { Tidy.Abs.ActionBody }
ActionBody : Expr { Tidy.Abs.ActionBodyOneLine $1 }
           | '{' ListExpr '}' { Tidy.Abs.ActionBodyMultiLine $2 }

ListExpr :: { [Tidy.Abs.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

Expr :: { Tidy.Abs.Expr }
Expr : Expr1 { $1 }
     | Expr1 BooleanOperator Expr { Tidy.Abs.EBooleanOperator $1 $2 $3 }

Expr1 :: { Tidy.Abs.Expr }
Expr1 : Expr2 { $1 }
      | Expr1 RelationalOperator Expr2 { Tidy.Abs.ERelationalOperator $1 $2 $3 }

Expr2 :: { Tidy.Abs.Expr }
Expr2 : Expr3 { $1 }
      | Expr2 '+' Expr3 { Tidy.Abs.EAdd $1 $3 }
      | Expr2 '-' Expr3 { Tidy.Abs.ESubtract $1 $3 }
      | Expr2 '++' Expr3 { Tidy.Abs.EConcatenate $1 $3 }

Expr3 :: { Tidy.Abs.Expr }
Expr3 : Expr4 { $1 }
      | Expr3 '*' Expr4 { Tidy.Abs.EMultiply $1 $3 }
      | Expr3 '/' Expr4 { Tidy.Abs.EDivide $1 $3 }

Expr4 :: { Tidy.Abs.Expr }
Expr4 : Expr5 { $1 }
      | 'not' Expr5 { Tidy.Abs.EUnaryNot $2 }
      | '-' Expr5 { Tidy.Abs.EUnaryMinus $2 }

Expr5 :: { Tidy.Abs.Expr }
Expr5 : Expr6 { $1 }
      | LocalValueDecl { Tidy.Abs.ELocalValueDecl $1 }

Expr6 :: { Tidy.Abs.Expr }
Expr6 : Expr7 { $1 }
      | ImperativeControlFlow { Tidy.Abs.EImperativeControlFlow $1 }
      | FunctionalControlFlow { Tidy.Abs.EFunctionalControlFlow $1 }

Expr7 :: { Tidy.Abs.Expr }
Expr7 : Expr8 { $1 }
      | 'local' FunctionCall { Tidy.Abs.ELocalFunctionCall $2 }
      | 'local' ActionCall { Tidy.Abs.ELocalActionCall $2 }
      | ConstructorCall { Tidy.Abs.ECtorCall $1 }

Expr8 :: { Tidy.Abs.Expr }
Expr8 : Expr9 { $1 }
      | LambdaFunction { Tidy.Abs.ELambdaFunction $1 }
      | LambdaAction { Tidy.Abs.ELambdaAction $1 }

Expr9 :: { Tidy.Abs.Expr }
Expr9 : Expr10 { $1 }
      | GetExpr { Tidy.Abs.EGetExpr $1 }
      | DoExpr { Tidy.Abs.EDoExpr $1 }

Expr10 :: { Tidy.Abs.Expr }
Expr10 : '(' Expr ')' { $2 }
       | Literal { Tidy.Abs.ELiteral $1 }
       | ValueIdent { Tidy.Abs.ELocalValue $1 }

Literal :: { Tidy.Abs.Literal }
Literal : Integer { Tidy.Abs.LInt $1 }
        | Boolean { Tidy.Abs.LBool $1 }
        | Char { Tidy.Abs.LChar $1 }
        | String { Tidy.Abs.LString $1 }
        | Void { Tidy.Abs.LVoid $1 }

Boolean :: { Tidy.Abs.Boolean }
Boolean : 'True' { Tidy.Abs.BTrue } | 'False' { Tidy.Abs.BFalse }

Void :: { Tidy.Abs.Void }
Void : 'Pass' { Tidy.Abs.VPass }

LocalValueDecl :: { Tidy.Abs.LocalValueDecl }
LocalValueDecl : 'value' ValueDecl { Tidy.Abs.LocalVDecl $2 }

LambdaFunction :: { Tidy.Abs.LambdaFunction }
LambdaFunction : 'get' ParameterList '->' Expr ';' { Tidy.Abs.LambdaFunctionOneLine $2 $4 }
               | 'get' ParameterList '->' '{' Expr '}' { Tidy.Abs.LambdaFunctionMultiLine $2 $5 }

LambdaAction :: { Tidy.Abs.LambdaAction }
LambdaAction : 'do' ParameterList '->' Expr ';' { Tidy.Abs.LambdaActionOneLine $2 $4 }
             | 'do' ParameterList '->' '{' ListExpr '}' { Tidy.Abs.LambdaActionMultiLine $2 $5 }

ArgumentList :: { Tidy.Abs.ArgumentList }
ArgumentList : {- empty -} { Tidy.Abs.ArgListAbsent }
             | '(' ListFunctionArgument ')' { Tidy.Abs.ArgListPresent $2 }

ListFunctionArgument :: { [Tidy.Abs.FunctionArgument] }
ListFunctionArgument : {- empty -} { [] }
                     | FunctionArgument { (:[]) $1 }
                     | FunctionArgument ',' ListFunctionArgument { (:) $1 $3 }

FunctionArgument :: { Tidy.Abs.FunctionArgument }
FunctionArgument : Expr { Tidy.Abs.FunctionArg $1 }

FunctionCall :: { Tidy.Abs.FunctionCall }
FunctionCall : '.' FunctionIdent ArgumentList { Tidy.Abs.FCall $2 $3 }

ActionCall :: { Tidy.Abs.ActionCall }
ActionCall : '#' FunctionIdent ArgumentList { Tidy.Abs.ACall $2 $3 }

ConstructorCall :: { Tidy.Abs.ConstructorCall }
ConstructorCall : ClassIdent ArgumentList { Tidy.Abs.CCall $1 $2 }

GetExpr :: { Tidy.Abs.GetExpr }
GetExpr : ValueIdent FunctionCall { Tidy.Abs.GetExprInstance $1 $2 }
        | ClassIdent FunctionCall { Tidy.Abs.GetExprStatic $1 $2 }
        | GetExpr FunctionCall { Tidy.Abs.GetExprChain $1 $2 }

DoExpr :: { Tidy.Abs.DoExpr }
DoExpr : ValueIdent ActionCall { Tidy.Abs.DoExprInstance $1 $2 }
       | ClassIdent ActionCall { Tidy.Abs.DoExprStatic $1 $2 }
       | GetExpr ActionCall { Tidy.Abs.DoExprChain $1 $2 }

ImperativeControlFlow :: { Tidy.Abs.ImperativeControlFlow }
ImperativeControlFlow : 'while' '(' Expr ')' '{' ListExpr '}' { Tidy.Abs.IWhile $3 $6 }
                      | 'for' '(' ValueDecl 'in' Expr ')' '{' ListExpr '}' { Tidy.Abs.IForeach $3 $5 $8 }
                      | 'if' '(' Expr ')' '{' ListExpr '}' OptionalElseBranch { Tidy.Abs.IIf $3 $6 $8 }

OptionalElseBranch :: { Tidy.Abs.OptionalElseBranch }
OptionalElseBranch : 'else' '{' ListExpr '}' { Tidy.Abs.ElsePresent $3 }
                   | {- empty -} { Tidy.Abs.ElseAbsent }

FunctionalControlFlow :: { Tidy.Abs.FunctionalControlFlow }
FunctionalControlFlow : 'if' '(' Expr ')' ThenBranch ElseBranch { Tidy.Abs.FIfThenElse $3 $5 $6 }
                      | 'match' Expr '{' ListMatchCase '}' { Tidy.Abs.FMatch $2 $4 }

ThenBranch :: { Tidy.Abs.ThenBranch }
ThenBranch : 'then' Expr ';' { Tidy.Abs.ThenOneLine $2 }
           | 'then' '{' Expr '}' { Tidy.Abs.ThenMultiLine $3 }

ElseBranch :: { Tidy.Abs.ElseBranch }
ElseBranch : 'else' Expr ';' { Tidy.Abs.ElseOneLine $2 }
           | 'else' '{' Expr '}' { Tidy.Abs.ElseMultiLine $3 }
           | 'elif' '(' Expr ')' ThenBranch ElseBranch { Tidy.Abs.ElseIf $3 $5 $6 }

ListMatchCase :: { [Tidy.Abs.MatchCase] }
ListMatchCase : {- empty -} { [] }
              | MatchCase ListMatchCase { (:) $1 $2 }

MatchCase :: { Tidy.Abs.MatchCase }
MatchCase : 'case' Pattern '->' Expr { Tidy.Abs.Case $2 $4 }

Pattern :: { Tidy.Abs.Pattern }
Pattern : ClassIdent { Tidy.Abs.TypePattern $1 }

RelationalOperator :: { Tidy.Abs.RelationalOperator }
RelationalOperator : '<' { Tidy.Abs.RLess }
                   | '<=' { Tidy.Abs.RLessEqual }
                   | '>' { Tidy.Abs.RGreater }
                   | '>=' { Tidy.Abs.RGreaterEqual }
                   | '==' { Tidy.Abs.REqual }
                   | '!=' { Tidy.Abs.RNotEqual }

BooleanOperator :: { Tidy.Abs.BooleanOperator }
BooleanOperator : 'and' { Tidy.Abs.BAnd } | 'or' { Tidy.Abs.BOr }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

