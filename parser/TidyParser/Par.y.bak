-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module TidyParser.Par
  ( happyError
  , myLexer
  , pProgram
  ) where
import qualified TidyParser.Abs
import TidyParser.Lex
}

%name pProgram Program
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '#' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '*' { PT _ (TS _ 5) }
  '+' { PT _ (TS _ 6) }
  '++' { PT _ (TS _ 7) }
  ',' { PT _ (TS _ 8) }
  '-' { PT _ (TS _ 9) }
  '->' { PT _ (TS _ 10) }
  '.' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ':' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '=' { PT _ (TS _ 17) }
  '==' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  'False' { PT _ (TS _ 21) }
  'Pass' { PT _ (TS _ 22) }
  'True' { PT _ (TS _ 23) }
  '[' { PT _ (TS _ 24) }
  ']' { PT _ (TS _ 25) }
  'abstract' { PT _ (TS _ 26) }
  'actions:' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'case' { PT _ (TS _ 29) }
  'class' { PT _ (TS _ 30) }
  'do' { PT _ (TS _ 31) }
  'else' { PT _ (TS _ 32) }
  'extends' { PT _ (TS _ 33) }
  'for' { PT _ (TS _ 34) }
  'functions:' { PT _ (TS _ 35) }
  'get' { PT _ (TS _ 36) }
  'if' { PT _ (TS _ 37) }
  'immutable' { PT _ (TS _ 38) }
  'in' { PT _ (TS _ 39) }
  'local' { PT _ (TS _ 40) }
  'match' { PT _ (TS _ 41) }
  'mutable' { PT _ (TS _ 42) }
  'not' { PT _ (TS _ 43) }
  'or' { PT _ (TS _ 44) }
  'override' { PT _ (TS _ 45) }
  'private' { PT _ (TS _ 46) }
  'singleton' { PT _ (TS _ 47) }
  'then' { PT _ (TS _ 48) }
  'value' { PT _ (TS _ 49) }
  'values:' { PT _ (TS _ 50) }
  'variables:' { PT _ (TS _ 51) }
  'while' { PT _ (TS _ 52) }
  'with' { PT _ (TS _ 53) }
  '{' { PT _ (TS _ 54) }
  '}' { PT _ (TS _ 55) }
  L_charac { PT _ (TC $$) }
  L_integ  { PT _ (TI $$) }
  L_quoted { PT _ (TL $$) }
  L_UpperCaseIdent { PT _ (T_UpperCaseIdent $$) }
  L_LowerCaseIdent { PT _ (T_LowerCaseIdent $$) }

%%

Char    :: { Char }
Char     : L_charac { (read ($1)) :: Char }

Integer :: { Integer }
Integer  : L_integ  { (read ($1)) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

UpperCaseIdent :: { TidyParser.Abs.UpperCaseIdent}
UpperCaseIdent  : L_UpperCaseIdent { TidyParser.Abs.UpperCaseIdent $1 }

LowerCaseIdent :: { TidyParser.Abs.LowerCaseIdent}
LowerCaseIdent  : L_LowerCaseIdent { TidyParser.Abs.LowerCaseIdent $1 }

Program :: { TidyParser.Abs.Program }
Program : ListClassDecl { TidyParser.Abs.ProgramEntrypoint $1 }

ListClassIdent :: { [TidyParser.Abs.ClassIdent] }
ListClassIdent : {- empty -} { [] }
               | ClassIdent { (:[]) $1 }
               | ClassIdent ',' ListClassIdent { (:) $1 $3 }

ClassIdent :: { TidyParser.Abs.ClassIdent }
ClassIdent : UpperCaseIdent { TidyParser.Abs.CIdent $1 }

ListClassDecl :: { [TidyParser.Abs.ClassDecl] }
ListClassDecl : ClassDecl { (:[]) $1 }
              | ClassDecl ListClassDecl { (:) $1 $2 }

ClassDecl :: { TidyParser.Abs.ClassDecl }
ClassDecl : ClassType 'class' ClassIdent Inheritance ClassBody { TidyParser.Abs.ClassDeclConcrete $1 $3 $4 $5 }
          | 'abstract' ClassType 'class' ClassIdent Inheritance ClassBody { TidyParser.Abs.ClassDeclAbstract $2 $4 $5 $6 }

Inheritance :: { TidyParser.Abs.Inheritance }
Inheritance : {- empty -} { TidyParser.Abs.SuperclassAbsent }
            | 'extends' ClassIdent { TidyParser.Abs.SuperclassPresent $2 }

ClassBody :: { TidyParser.Abs.ClassBody }
ClassBody : {- empty -} { TidyParser.Abs.ClassBodyEmpty }
          | '{' ValuesSection VariablesSection FunctionsSection ActionsSection '}' { TidyParser.Abs.ClassBodyFilled $2 $3 $4 $5 }

ClassType :: { TidyParser.Abs.ClassType }
ClassType : 'mutable' { TidyParser.Abs.MMutable }
          | 'immutable' { TidyParser.Abs.MImmutable }
          | 'singleton' { TidyParser.Abs.MSingleton }

ValuesSection :: { TidyParser.Abs.ValuesSection }
ValuesSection : {- empty -} { TidyParser.Abs.ValuesAbsent }
              | 'values:' ValSBody { TidyParser.Abs.ValuesPresent $2 }

VariablesSection :: { TidyParser.Abs.VariablesSection }
VariablesSection : {- empty -} { TidyParser.Abs.VariablesAbsent }
                 | 'variables:' VarSBody { TidyParser.Abs.VariablesPresent $2 }

FunctionsSection :: { TidyParser.Abs.FunctionsSection }
FunctionsSection : {- empty -} { TidyParser.Abs.FunctionsAbsent }
                 | 'functions:' FSBody { TidyParser.Abs.FunctionsPresent $2 }

ActionsSection :: { TidyParser.Abs.ActionsSection }
ActionsSection : {- empty -} { TidyParser.Abs.ActionsAbsent }
               | 'actions:' ASBody { TidyParser.Abs.ActionsPresent $2 }

ValSBody :: { TidyParser.Abs.ValSBody }
ValSBody : '{' ListValueDecl '}' { TidyParser.Abs.ValSBody $2 }

ValueIdent :: { TidyParser.Abs.ValueIdent }
ValueIdent : LowerCaseIdent { TidyParser.Abs.VIdent $1 }

ValueType :: { TidyParser.Abs.ValueType }
ValueType : ClassIdent { TidyParser.Abs.ValueTypeClass $1 }
          | ClassIdent '[' ListClassIdent ']' { TidyParser.Abs.ValueTypeGeneric $1 $3 }
          | 'get' MethodType { TidyParser.Abs.ValueTypeFunction $2 }
          | 'do' MethodType { TidyParser.Abs.ValueTypeAction $2 }

ListValueDecl :: { [TidyParser.Abs.ValueDecl] }
ListValueDecl : {- empty -} { [] }
              | ValueDecl ';' ListValueDecl { (:) $1 $3 }

ValueDecl :: { TidyParser.Abs.ValueDecl }
ValueDecl : ValueDeclProper { TidyParser.Abs.PublicValueDecl $1 }
          | 'private' ValueDeclProper { TidyParser.Abs.PrivateValueDecl $2 }

ValueDeclProper :: { TidyParser.Abs.ValueDeclProper }
ValueDeclProper : ValueIdent ':' ValueType { TidyParser.Abs.UninitialisedValue $1 $3 }
                | ValueIdent ':' ValueType '=' Expr { TidyParser.Abs.InitialisedValue $1 $3 $5 }

VarSBody :: { TidyParser.Abs.VarSBody }
VarSBody : '{' ListValueDecl '}' { TidyParser.Abs.VarSBody $2 }

FSBody :: { TidyParser.Abs.FSBody }
FSBody : {- empty -} { TidyParser.Abs.FSBodyEmpty }
       | '{' ListFunctionDecl '}' { TidyParser.Abs.FSBodyFilled $2 }

FunctionIdent :: { TidyParser.Abs.FunctionIdent }
FunctionIdent : LowerCaseIdent { TidyParser.Abs.FIdent $1 }

MethodType :: { TidyParser.Abs.MethodType }
MethodType : '(' ListValueDecl ')' '->' ValueType { TidyParser.Abs.FType $2 $5 }

ListFunctionDecl :: { [TidyParser.Abs.FunctionDecl] }
ListFunctionDecl : {- empty -} { [] }
                 | FunctionDecl ListFunctionDecl { (:) $1 $2 }

FunctionDecl :: { TidyParser.Abs.FunctionDecl }
FunctionDecl : 'override' FunctionIdent ':' MethodType '=' FunctionBody { TidyParser.Abs.OverrideFunctionDecl $2 $4 $6 }
             | FunctionIdent ':' MethodType '=' FunctionBody { TidyParser.Abs.PublicFunctionDecl $1 $3 $5 }
             | 'private' FunctionIdent ':' MethodType '=' FunctionBody { TidyParser.Abs.PrivateFunctionDecl $2 $4 $6 }

FunctionBody :: { TidyParser.Abs.FunctionBody }
FunctionBody : Expr { TidyParser.Abs.FunctionBodyOneLine $1 }
             | '{' Expr '}' WithValues { TidyParser.Abs.FunctionBodyMultiLine $2 $4 }

WithValues :: { TidyParser.Abs.WithValues }
WithValues : {- empty -} { TidyParser.Abs.WithValuesAbsent }
           | 'with' ValuesSection { TidyParser.Abs.WithValuesPresent $2 }

ASBody :: { TidyParser.Abs.ASBody }
ASBody : {- empty -} { TidyParser.Abs.ASBodyEmpty }
       | '{' ListActionDecl '}' { TidyParser.Abs.ASBodyFilled $2 }

ListActionDecl :: { [TidyParser.Abs.ActionDecl] }
ListActionDecl : {- empty -} { [] }
               | ActionDecl ListActionDecl { (:) $1 $2 }

ActionDecl :: { TidyParser.Abs.ActionDecl }
ActionDecl : 'override' FunctionIdent ':' MethodType '=' ActionBody { TidyParser.Abs.OverrideActionDecl $2 $4 $6 }
           | FunctionIdent ':' MethodType '=' ActionBody { TidyParser.Abs.PublicActionDecl $1 $3 $5 }
           | 'private' FunctionIdent ':' MethodType '=' ActionBody { TidyParser.Abs.PrivateActionDecl $2 $4 $6 }

ActionBody :: { TidyParser.Abs.ActionBody }
ActionBody : Expr { TidyParser.Abs.ActionBodyOneLine $1 }
           | '{' ListExpr '}' { TidyParser.Abs.ActionBodyMultiLine $2 }

ListExpr :: { [TidyParser.Abs.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

Expr :: { TidyParser.Abs.Expr }
Expr : Expr1 { $1 }
     | Expr1 BooleanOperator Expr { TidyParser.Abs.EBooleanOperator $1 $2 $3 }

Expr1 :: { TidyParser.Abs.Expr }
Expr1 : Expr2 { $1 }
      | Expr1 RelationalOperator Expr2 { TidyParser.Abs.ERelationalOperator $1 $2 $3 }

Expr2 :: { TidyParser.Abs.Expr }
Expr2 : Expr3 { $1 }
      | Expr2 '+' Expr3 { TidyParser.Abs.EAdd $1 $3 }
      | Expr2 '-' Expr3 { TidyParser.Abs.ESubtract $1 $3 }
      | Expr2 '++' Expr3 { TidyParser.Abs.EConcatenate $1 $3 }

Expr3 :: { TidyParser.Abs.Expr }
Expr3 : Expr4 { $1 }
      | Expr3 '*' Expr4 { TidyParser.Abs.EMultiply $1 $3 }
      | Expr3 '/' Expr4 { TidyParser.Abs.EDivide $1 $3 }

Expr4 :: { TidyParser.Abs.Expr }
Expr4 : Expr5 { $1 }

Expr5 :: { TidyParser.Abs.Expr }
Expr5 : Expr6 { $1 }
      | LambdaFunction { TidyParser.Abs.ELambdaFunction $1 }
      | LambdaAction { TidyParser.Abs.ELambdaAction $1 }
      | 'local' FunctionCall { TidyParser.Abs.ELocalFunctionCall $2 }
      | 'local' ActionCall { TidyParser.Abs.ELocalActionCall $2 }
      | ConstructorCall { TidyParser.Abs.ECtorCall $1 }
      | GetExpr { TidyParser.Abs.EGetExpr $1 }
      | DoExpr { TidyParser.Abs.EDoExpr $1 }
      | ImperativeControlFlow { TidyParser.Abs.EImperativeControlFlow $1 }
      | FunctionalControlFlow { TidyParser.Abs.EFunctionalControlFlow $1 }
      | LocalValueDecl { TidyParser.Abs.ELocalValueDecl $1 }

Expr6 :: { TidyParser.Abs.Expr }
Expr6 : Expr7 { $1 }
      | 'not' Expr7 { TidyParser.Abs.EUnaryNot $2 }
      | '-' Expr7 { TidyParser.Abs.EUnaryMinus $2 }

Expr7 :: { TidyParser.Abs.Expr }
Expr7 : '(' Expr ')' { $2 }
      | Literal { TidyParser.Abs.ELiteral $1 }
      | ValueIdent { TidyParser.Abs.ELocalValue $1 }

Literal :: { TidyParser.Abs.Literal }
Literal : Integer { TidyParser.Abs.LInt $1 }
        | Boolean { TidyParser.Abs.LBool $1 }
        | Char { TidyParser.Abs.LChar $1 }
        | String { TidyParser.Abs.LString $1 }
        | Void { TidyParser.Abs.LVoid $1 }

Boolean :: { TidyParser.Abs.Boolean }
Boolean : 'True' { TidyParser.Abs.BTrue }
        | 'False' { TidyParser.Abs.BFalse }

Void :: { TidyParser.Abs.Void }
Void : 'Pass' { TidyParser.Abs.VPass }

LocalValueDecl :: { TidyParser.Abs.LocalValueDecl }
LocalValueDecl : 'value' ValueDecl ';' { TidyParser.Abs.LocalVDecl $2 }

LambdaFunction :: { TidyParser.Abs.LambdaFunction }
LambdaFunction : 'get' '(' ListValueDecl ')' '->' Expr ';' { TidyParser.Abs.LambdaFunctionOneLine $3 $6 }
               | 'get' '(' ListValueDecl ')' '->' '{' Expr '}' { TidyParser.Abs.LambdaFunctionMultiLine $3 $7 }

LambdaAction :: { TidyParser.Abs.LambdaAction }
LambdaAction : 'do' '(' ListValueDecl ')' '->' Expr ';' { TidyParser.Abs.LambdaActionOneLine $3 $6 }
             | 'do' '(' ListValueDecl ')' '->' '{' ListExpr '}' { TidyParser.Abs.LambdaActionMultiLine $3 $7 }

FunctionCall :: { TidyParser.Abs.FunctionCall }
FunctionCall : '.' FunctionIdent { TidyParser.Abs.FunctionCallNoArgs $2 }
             | '.' FunctionIdent '(' ListFunctionArgument ')' { TidyParser.Abs.FunctionCallWithArgs $2 $4 }

ActionCall :: { TidyParser.Abs.ActionCall }
ActionCall : '#' FunctionIdent { TidyParser.Abs.ActionCallNoArgs $2 }
           | '#' FunctionIdent '(' ListFunctionArgument ')' { TidyParser.Abs.ActionCallWithArgs $2 $4 }

ListFunctionArgument :: { [TidyParser.Abs.FunctionArgument] }
ListFunctionArgument : {- empty -} { [] }
                     | FunctionArgument { (:[]) $1 }
                     | FunctionArgument ',' ListFunctionArgument { (:) $1 $3 }

FunctionArgument :: { TidyParser.Abs.FunctionArgument }
FunctionArgument : Expr { TidyParser.Abs.FunctionArg $1 }

ConstructorCall :: { TidyParser.Abs.ConstructorCall }
ConstructorCall : ClassIdent { TidyParser.Abs.CtorCallNoArgs $1 }
                | ClassIdent '(' ListFunctionArgument ')' { TidyParser.Abs.CtorCallWithArgs $1 $3 }

GetExpr :: { TidyParser.Abs.GetExpr }
GetExpr : ValueIdent FunctionCall { TidyParser.Abs.GetExprInstance $1 $2 }
        | ClassIdent FunctionCall { TidyParser.Abs.GetExprStatic $1 $2 }
        | GetExpr FunctionCall { TidyParser.Abs.GetExprChain $1 $2 }

DoExpr :: { TidyParser.Abs.DoExpr }
DoExpr : ValueIdent ActionCall { TidyParser.Abs.DoExprInstance $1 $2 }
       | ClassIdent ActionCall { TidyParser.Abs.DoExprStatic $1 $2 }
       | GetExpr ActionCall { TidyParser.Abs.DoExprChain $1 $2 }

ImperativeControlFlow :: { TidyParser.Abs.ImperativeControlFlow }
ImperativeControlFlow : 'while' '(' Expr ')' '{' ListExpr '}' { TidyParser.Abs.IWhile $3 $6 }
                      | 'for' '(' ValueDecl 'in' Expr ')' '{' ListExpr '}' { TidyParser.Abs.IForeach $3 $5 $8 }
                      | 'if' '(' Expr ')' '{' ListExpr '}' OptionalElseBranch { TidyParser.Abs.IIf $3 $6 $8 }

OptionalElseBranch :: { TidyParser.Abs.OptionalElseBranch }
OptionalElseBranch : 'else' '{' ListExpr '}' { TidyParser.Abs.ElsePresent $3 }
                   | {- empty -} { TidyParser.Abs.ElseAbsent }

FunctionalControlFlow :: { TidyParser.Abs.FunctionalControlFlow }
FunctionalControlFlow : 'if' '(' Expr ')' ThenBranch ElseBranch { TidyParser.Abs.FIfThenElse $3 $5 $6 }
                      | 'match' Expr '{' ListMatchCase '}' { TidyParser.Abs.FMatch $2 $4 }

ThenBranch :: { TidyParser.Abs.ThenBranch }
ThenBranch : 'then' Expr { TidyParser.Abs.ThenOneLine $2 }
           | 'then' '{' Expr '}' { TidyParser.Abs.ThenMultiLine $3 }

ElseBranch :: { TidyParser.Abs.ElseBranch }
ElseBranch : 'else' Expr { TidyParser.Abs.ElseOneLine $2 }
           | 'else' '{' Expr '}' { TidyParser.Abs.ElseMultiLine $3 }

ListMatchCase :: { [TidyParser.Abs.MatchCase] }
ListMatchCase : {- empty -} { [] }
              | MatchCase ListMatchCase { (:) $1 $2 }

MatchCase :: { TidyParser.Abs.MatchCase }
MatchCase : 'case' Pattern '->' Expr { TidyParser.Abs.Case $2 $4 }

Pattern :: { TidyParser.Abs.Pattern }
Pattern : ClassIdent { TidyParser.Abs.TypePattern $1 }

RelationalOperator :: { TidyParser.Abs.RelationalOperator }
RelationalOperator : '<' { TidyParser.Abs.RLess }
                   | '<=' { TidyParser.Abs.RLessEqual }
                   | '>' { TidyParser.Abs.RGreater }
                   | '>=' { TidyParser.Abs.RGreaterEqual }
                   | '==' { TidyParser.Abs.REqual }
                   | '!=' { TidyParser.Abs.RNotEqual }

BooleanOperator :: { TidyParser.Abs.BooleanOperator }
BooleanOperator : 'and' { TidyParser.Abs.BAnd }
                | 'or' { TidyParser.Abs.BOr }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

