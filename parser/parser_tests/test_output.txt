141 rules accepted

Use Alex 3 to compile Tidy/Lex.x.
refreshing unchanged file ./Tidy/Abs.hs
refreshing unchanged file ./Tidy/Print.hs
refreshing unchanged file ./Tidy/Lex.x
refreshing unchanged file ./Tidy/Par.y
refreshing unchanged file ./Tidy/Test.hs
refreshing unchanged file ./Tidy/ErrM.hs
refreshing unchanged file ./Tidy/Skel.hs
refreshing unchanged file ./Tidy/Doc.txt
refreshing unchanged file ./Makefile
alex --ghc Tidy/Lex.x
happy --ghc --coerce --array --info Tidy/Par.y
ghc -dynamic --make Tidy/Test.hs -o Tidy/Test
[1 of 6] Compiling Tidy.Abs         ( Tidy/Abs.hs, Tidy/Abs.o )
[2 of 6] Compiling Tidy.Lex         ( Tidy/Lex.hs, Tidy/Lex.o )
[3 of 6] Compiling Tidy.Par         ( Tidy/Par.hs, Tidy/Par.o )
[4 of 6] Compiling Tidy.Print       ( Tidy/Print.hs, Tidy/Print.o )
[5 of 6] Compiling Tidy.Skel        ( Tidy/Skel.hs, Tidy/Skel.o )
[6 of 6] Compiling Main             ( Tidy/Test.hs, Tidy/Test.o )
Linking Tidy/Test ...

Parse Successful!

[Abstract Syntax]

ProgramEntrypoint [ClassDeclConcrete MMutable (CIdent (UpperCaseIdent "PhoneMessageReceiver")) (SuperclassPresent (CIdent (UpperCaseIdent "MessageReceiver"))) (ClassBodyFilled (ValuesPresent (ValSBodyMultiLine [PublicValueDecl (InitialisedValue (VIdent (LowerCaseIdent "messageReceived")) (ValueTypeClass (CIdent (UpperCaseIdent "String"))) (ELiteral (LString "You got a new message!"))),PublicValueDecl (InitialisedValue (VIdent (LowerCaseIdent "messageInvalid")) (ValueTypeClass (CIdent (UpperCaseIdent "String"))) (ELiteral (LString "Invalid message"))),PublicValueDecl (InitialisedValue (VIdent (LowerCaseIdent "maxMessageLength")) (ValueTypeClass (CIdent (UpperCaseIdent "Int"))) (ELiteral (LInt 100))),PublicValueDecl (UninitialisedValue (VIdent (LowerCaseIdent "notificationChannels")) (ValueTypeGeneric (CIdent (UpperCaseIdent "List")) [CIdent (UpperCaseIdent "NotificationChannel")]))])) (VariablesPresent (VarSBodyMultiLine [PublicValueDecl (InitialisedValue (VIdent (LowerCaseIdent "messages")) (ValueTypeGeneric (CIdent (UpperCaseIdent "List")) [CIdent (UpperCaseIdent "Message")]) (ECtorCall (CtorCallWithArgs (CIdent (UpperCaseIdent "List")) [])))])) (FunctionsPresent (FSBodyFilled [PrivateFunctionDecl (FIdent (LowerCaseIdent "parseMessage")) (FType [PublicValueDecl (UninitialisedValue (VIdent (LowerCaseIdent "message")) (ValueTypeClass (CIdent (UpperCaseIdent "Message"))))] (ValueTypeClass (CIdent (UpperCaseIdent "String")))) (FunctionBodyMultiLine (ELocalValue (VIdent (LowerCaseIdent "x"))) WithValuesAbsent),PrivateFunctionDecl (FIdent (LowerCaseIdent "validateMessage")) (FType [PublicValueDecl (UninitialisedValue (VIdent (LowerCaseIdent "message")) (ValueTypeClass (CIdent (UpperCaseIdent "Message"))))] (ValueTypeClass (CIdent (UpperCaseIdent "Bool")))) (FunctionBodyMultiLine (EBooleanOperator (EUnaryNot (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "message")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "empty")))))) BAnd (ERelationalOperator (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "message")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "length"))))) RLessEqual (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "maxMessageLength"))))))) WithValuesAbsent)])) (ActionsPresent (ASBodyFilled [OverrideActionDecl (FIdent (LowerCaseIdent "receive")) (FType [PublicValueDecl (UninitialisedValue (VIdent (LowerCaseIdent "message")) (ValueTypeClass (CIdent (UpperCaseIdent "Message"))))] (ValueTypeClass (CIdent (UpperCaseIdent "Bool")))) (ActionBodyMultiLine [EDoExpr (DoExprStatic (CIdent (UpperCaseIdent "System")) (FunctionCallWithArgs (FIdent (LowerCaseIdent "printLine")) [FunctionArg (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "messageReceived")))))])),ELocalValueDecl (LocalVDecl (PublicValueDecl (InitialisedValue (VIdent (LowerCaseIdent "response")) (ValueTypeClass (CIdent (UpperCaseIdent "String"))) (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallWithArgs (FIdent (LowerCaseIdent "parseMessage")) [FunctionArg (ELocalValue (VIdent (LowerCaseIdent "message")))])))))),EDoExpr (DoExprStatic (CIdent (UpperCaseIdent "System")) (FunctionCallWithArgs (FIdent (LowerCaseIdent "printLine")) [FunctionArg (ELocalValue (VIdent (LowerCaseIdent "response")))])),EImperativeControlFlow (IIf (ERelationalOperator (ELocalValue (VIdent (LowerCaseIdent "response"))) RNotEqual (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "messageInvalid")))))) [EDoExpr (DoExprInstance (VIdent (LowerCaseIdent "super")) (FunctionCallWithArgs (FIdent (LowerCaseIdent "receive")) [FunctionArg (ELocalValue (VIdent (LowerCaseIdent "message")))])),EDoExpr (DoExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallWithArgs (FIdent (LowerCaseIdent "messages")) [FunctionArg (EGetExpr (GetExprChain (GetExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "messages")))) (FunctionCallWithArgs (FIdent (LowerCaseIdent "add")) [FunctionArg (ELocalValue (VIdent (LowerCaseIdent "message")))])))])),EImperativeControlFlow (IForeach (PublicValueDecl (UninitialisedValue (VIdent (LowerCaseIdent "channel")) (ValueTypeClass (CIdent (UpperCaseIdent "NotificationChannel"))))) (EGetExpr (GetExprInstance (VIdent (LowerCaseIdent "this")) (FunctionCallNoArgs (FIdent (LowerCaseIdent "notificationChannels"))))) [EDoExpr (DoExprInstance (VIdent (LowerCaseIdent "channel")) (FunctionCallWithArgs (FIdent (LowerCaseIdent "notify")) [FunctionArg (ELocalValue (VIdent (LowerCaseIdent "response")))]))]),ELiteral (LBool BTrue)] (ElsePresent [ELiteral (LBool BFalse)]))])])))]

[Linearized tree]

mutable class PhoneMessageReceiver extends MessageReceiver {
  values: {
    messageReceived : String = "You got a new message!", messageInvalid : String = "Invalid message", maxMessageLength : Int = 100, notificationChannels : List [NotificationChannel]
  }
  variables: {
    messages : List [Message] = List ()
  }
  functions: {
    private parseMessage : (message : Message) -> String = {
      x
    }
    private validateMessage : (message : Message) -> Bool = {
      not message . empty and message . length <= this . maxMessageLength
    }
    }
  actions: {
    override receive : (message : Message) -> Bool = {
      System # printLine (this . messageReceived) value response : String = this . parseMessage (message) System # printLine (response) if (response != this . messageInvalid) {
        super # receive (message) this # messages (this . messages . add (message)) for (channel : NotificationChannel in this . notificationChannels) {
          channel # notify (response)
        }
        True
      }
      else {
        False
      }
      }
    }
  }

