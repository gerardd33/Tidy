-- PROGRAMS -----------------------------------

entrypoints Program ;
Program. Program ::= [ClassDecl] ;


-- COMMENTS -----------------------------------

comment "//" ;
comment "/*" "*/" ;


-- CLASS DECLARATIONS -------------------------

ClassIdent. ClassIdent ::= Ident ;
-- TODO starts with upper case

separator nonempty ClassDecl "" ;
ClassDeclConcrete. ClassDecl ::= ClassType "class" ClassIdent ClassBody ;
ClassDeclAbstract. ClassDecl ::= "abstract" ClassType "class" ClassIdent ClassBody ;


ClassBodyEmpty. ClassBody ::= ;
ClassBodyFilled. ClassBody ::= "{" ValuesSection VariablesSection FunctionsSection ActionsSection "}" ;


-- CLASS MODIFIERS ----------------------------

MMutable. ClassType ::= "mutable" ;
MImmutable. ClassType ::= "immutable" ;
MSingleton. ClassType ::= "singleton" ;


-- CLASS SECTION DECLARATIONS -----------------

ValuesAbsent. ValuesSection ::= ;
ValuesPresent. ValuesSection ::= "values:" ValSBody ;

VariablesAbsent. VariablesSection ::= ;
VariablesPresent. VariablesSection ::= "variables:" VarSBody ;

FunctionsAbsent. FunctionsSection ::= ;
FunctionsPresent. FunctionsSection ::= "functions:" FSBody ;

ActionsAbsent. ActionsSection ::= ;
ActionsPresent. ActionsSection ::= "actions:" ASBody ;


-- VALUES SECTION -----------------------------

ValSBodyEmpty. ValSBody ::= ;
ValSBodyOneLine. ValSBody ::= [ValueDecl] ;
ValSBodyMultiLine. ValSBody ::= "{" [ValueDecl] "}" ;

ValueIdent. ValueIdent ::= Ident ;
-- TODO if starts with lower case then normal value, else a constant 
ValueType. ValueType ::= ClassIdent ;
-- TODO doesn't work with generic types, doesn't work with function types

separator ValueDecl "," ;
UninitialisedValue. ValueDecl ::= ValueIdent ":" ValueType ;
InitialisedValue. ValueDecl ::= ValueIdent ":" ValueType "=" Expr ;


-- VARIABLES SECTION --------------------------

VarSBodyEmpty. VarSBody ::= ;
VarSBodyOneLine. VarSBody ::= [ValueDecl] ;
VarSBodyMultiLine. VarSBody ::= "{" [ValueDecl] "}" ;


-- FUNCTIONS SECTION --------------------------

FSBodyEmpty. FSBody ::= ;
FSBodyFilled. FSBody ::= "{" [FunctionDecl] "}" ;

FunctionIdent. FunctionIdent ::= Ident ;
-- TODO must start with lower case
FunctionType. FunctionType ::= "(" [ValueDecl] ")" "->" ValueType;
-- TODO merge FunctionType and valueType, extract types to a different set of rules in general, after it's working
-- TODO should be handled better, with connection to function objects to be pure OOP
-- TODO doesn't work with generic types, doesn't work with function parameters/return types

separator FunctionDecl "" ; 
PublicFunctionDecl. FunctionDecl ::= FunctionIdent ":" FunctionType "=" FunctionBody ;
PrivateFunctionDecl. FunctionDecl ::= "private" FunctionIdent ":" FunctionType "=" FunctionBody ;

FunctionBodyOneLine. FunctionBody ::= Expr ;
FunctionBodyMultiLine. FunctionBody ::= "{" Expr "}" WithValues ;

WithValuesAbsent. WithValues ::= ;
WithValuesPresent. WithValues ::= "with" ValuesSection ;


-- ACTIONS SECTION ----------------------------

ASBodyEmpty. ASBody ::= ;
ASBodyFilled. ASBody ::= "{" [ActionDecl] "}" ;

separator ActionDecl "" ; 
PublicActionDecl. ActionDecl ::= FunctionIdent ":" FunctionType "=" ActionBody ;
PrivateActionDecl. ActionDecl ::= "private" FunctionIdent ":" FunctionType "=" ActionBody ;

ActionBodyOneLine. ActionBody ::= Expr ;
ActionBodyMultiLine. ActionBody ::= "{" [Expr] "}" ;


-- EXPRESSIONS -------------------------------

separator Expr "" ;
coercions Expr 5 ;

ELiteral. Expr5 ::= Literal ;
EValue. Expr5 ::= ValueIdent ;
EImperative. Expr5 ::= Imperative ;

EUnaryNot. Expr4 ::= "not" Expr5 ;
EUnaryMinus. Expr4 ::= "-" Expr5 ;

EMultiply. Expr3 ::= Expr3 "*" Expr4 ;
EDivide. Expr3 ::= Expr3 "/" Expr4 ;

EAdd. Expr2 ::= Expr2 "+" Expr3 ;
ESubtract. Expr2 ::= Expr2 "-" Expr3 ;

ERelationalOperator. Expr1 ::= Expr1 RelationalOperator Expr2 ;

EBooleanOperator. Expr ::= Expr1 BooleanOperator Expr ;


-- LITERALS ----------------------------------

LInt. Literal ::= Integer ;
LBool. Literal ::= Boolean ;
LChar. Literal ::= Char ;
LString. Literal ::= String ;
LVoid. Literal ::= Void ;

BTrue. Boolean ::= "True" ;
BFalse. Boolean ::= "False" ;
VPass. Void ::= "Pass" ;


-- IMPERATIVE INSTRUCTIONS -------------------

IWhile. Imperative ::= "while" "(" Expr ")" "{" [Expr] "}" ;
IForeach. Imperative ::= "for" "(" ValueDecl "in" ValueIdent ")" "{" [Expr] "}" ;


-- RELATIONAL OPERATORS ----------------------

RLess. RelationalOperator ::= "<" ;
RLessEqual. RelationalOperator ::= "<=" ;
RGreater. RelationalOperator ::= ">" ;
RGreaterEqual. RelationalOperator ::= ">=" ;
REqual. RelationalOperator ::= "==" ;
RNotEqual. RelationalOperator ::= "!=" ;


-- BOOLEAN OPERATORS -------------------------

BAnd. BooleanOperator ::= "and" ;
BOr. BooleanOperator ::= "or" ;
